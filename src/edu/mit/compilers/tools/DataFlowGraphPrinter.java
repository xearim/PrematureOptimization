package edu.mit.compilers.tools;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;

import edu.mit.compilers.codegen.DataFlowNode;

/** Prints an DFG in DOT format. */
public class DataFlowGraphPrinter {
	
	    private final PrintStream printStream;
	    private final Map<DataFlowNode, Integer> nodeIds;
	    private int nextId;

	    /** Constructs a Printer that outputs to the given PrintStream. */
	    public DataFlowGraphPrinter(PrintStream printStream) {
	        this.printStream = printStream;
	        this.nextId = 0;
	        this.nodeIds = new HashMap<DataFlowNode, Integer>();
	    }

	    /** Print the DFG nodes reachable from 'start' in DOT format to the PrintStream. */
	    public void print(DataFlowNode start) {
	        printStream.println("digraph AST {");
	        printGraphFrom(start);
	        printStream.println("}");
	    }

	    /**
	     * Print the nodes and edges of the CFG reachable from 'node';
	     *
	     * <p>Each node is assigned a unique ID.  The graph is generated by expressing links from node
	     * to node, in the form "id1 -> id2;".
	     *
	     * <p>Each node is also declared with a label, which is TODO(jasonpr): Which is what?
	     *
	     * @param ast The AST to print.
	     * @return The id assigned to this node.  (Callers can use this id to draw an edge to this
	     * node.)
	     */
	    private int printGraphFrom(DataFlowNode node) {
	        if (nodeIds.containsKey(node)) {
	            // Draw nothing: we have already processed this node.
	            return nodeIds.get(node);
	        } else {
	            int nodeId = nextId++;
	            nodeIds.put(node, nodeId);
	            printStream.println(Dot.node(nodeId, node.nodeText()));
                for (DataFlowNode sink : node.getSuccessors()) {
                    int childId = printGraphFrom(sink);
                    // Draw an edge to the child, now that we have its id.
                    printStream.println(Dot.edge(nodeId, childId));
                }
                for (DataFlowNode sink : node.getPredecessors()) {
                    int childId = printGraphFrom(sink);
                    // Draw an edge to the child, now that we have its id.
                    printStream.println(Dot.edge(childId, nodeId));
                }
	            return nodeId;
	        }
	    }

}
