package edu.mit.compilers.tools;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;

import edu.mit.compilers.codegen.ControlFlowNode;

/** Prints an AST in DOT format. */
public class ControlFlowGraphPrinter {
    private final PrintStream printStream;
    private final Map<ControlFlowNode, Integer> nodeIds;
    private int nextId;

    /** Constructs an AstPrinter that outputs to the given PrintStream. */
    public ControlFlowGraphPrinter(PrintStream printStream) {
        this.printStream = printStream;
        this.nextId = 0;
        this.nodeIds = new HashMap<ControlFlowNode, Integer>();
    }

    /** Print the CFG nodes reachable from 'start' in DOT format to the PrintStream. */
    public void print(ControlFlowNode start) {
        printStream.println("digraph AST {");
        printGraphFrom(start);
        printStream.println("}");
    }

    /**
     * Print the nodes and edges of the CFG reachable from 'node';
     *
     * <p>Each node is assigned a unique ID.  The graph is generated by expressing links from node
     * to node, in the form "id1 -> id2;".
     *
     * <p>Each node is also declared with a label, which is TODO(jasonpr): Which is what?
     *
     * @param ast The AST to print.
     * @return The id assigned to this node.  (Callers can use this id to draw an edge to this
     * node.)
     */
    private int printGraphFrom(ControlFlowNode node) {
        if (nodeIds.containsKey(node)) {
            // Draw nothing: we have already processed this node.
            return nodeIds.get(node);
        } else {
            int nodeId = nextId++;
            nodeIds.put(node, nodeId);
            printStream.println(Dot.node(nodeId, node.toString()));
            for (ControlFlowNode sink : node.getSinks()) {
                int childId = printGraphFrom(sink);
                // Draw an edge to the child, now that we have its id.
                printStream.println(Dot.edge(nodeId, childId));
            }
            return nodeId;
        }
    }
}
